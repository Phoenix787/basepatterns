Автономное тестирование лямбда-выражений
-------------------------------------------
Автономным (модульным) тестированием называется методика тестирования отдельных
кусков кода с целью удостовериться, что они ведут себя, как задумано.

С точки зрения автономного тестирования кода, с лямбда-выра-
жениями связана одна проблема. Поскольку лямбда-выражение не
имеет имени, его невозможно вызвать из тестового кода напрямую.

Есть два заслуживающих внимания решения этой проблемы. Пер-
вое – рассматривать лямбда-выражение как блок кода внутри объем-
лющего его метода. Если пойти по этому пути, то мы должны будем
тестировать поведение объемлющего метода, а не самого лямбда-вы-
ражения.
(см. пример 1)

Иногда лямбда-выражение обладает сложной функционально-
стью. Быть может, в нем есть ряд граничных случаев или оно вычис-
ляет чрезвычайно важную для предметной области функцию. Вам
абсолютно необходимо протестировать эту часть кода, но она реали-
зована в виде лямбда-выражения, на которое невозможно сослаться.
В качестве примера такой проблемы рассмотрим метод, который
лишь немного сложнее преобразования списка строк в верхний ре-
гистр. Мы будем преобразовывать не всю строку, а только первый
символ. С помощью потоков и лямбда-выражений мы могли бы ре-
шить эту задачу, как показано в примере 2. Лямбда-выражение, вы-
полняющее преобразование, находится в точке 1.

Не используйте лямбда-выражение. Я понимаю, что такой совет
может показаться странным в книге, посвященной лямбда-выраже-
ниям, но стоит ли непременно пытаться оседлать корову? Если мы
согласимся, что не стоит, то возникает вопрос, как все же автономно
протестировать код, не жертвуя удобством библиотек с поддержкой
лямбда-выражений.
Используйте ссылки на методы.
Любой метод, который можно было бы написать в виде лямбда-выражения, можно также записать
в виде обычного метода, а затем обращаться к нему в других местах
программы с помощью ссылки на метод. (пример 2а)

Использование лямбда-выражений в тестовых двойниках (mock'и)
При написании автономных тестов нередко применяются тестовые
двойники , которые описывают ожидаемое поведение других компо-
нентов системы. Это полезно, потому что задача автономного тести-
рования – проверить работу класса или метода изолированно от всех
прочих частей программы, а тестовые двойники позволяют реализо-
вать такую изоляцию для целей тестирования.
! Хотя тестовые двойники часто называют подставными объектами (mock),
на самом деле есть два типа двойников: подставки и заглушки . Различие в
том, что подставки позволяют проверить поведение кода. Самое лучшее
изложение этого предмета см. в статье Мартина Фаулера по адресу http://
martinfowler.com/articles/mocksArentStubs.html.

Один из самых простых способов использования лямбда-выраже-
ний в тестовом коде – реализация облегченных заглушек. Это дей-
ствительно легко и естественно, если компонент, который необходи-
мо заглушить, уже является функциональным интерфейсом.

Пример 7.14  Использование лямбда-выражения в качестве
тестового двойника, передаваемого методу countFeature
@Test
public void canCountFeatures() {
OrderDomain order = new OrderDomain(asList(
newAlbum("Exile on Main St."),
newAlbum("Beggars Banquet"),
newAlbum("Aftermath"),
newAlbum("Let it Bleed")));
assertEquals(8, order.countFeature(album -> 2));
}

В большинстве тестовых двойников ожидания более сложные.
В таких случаях часто применяются каркасы типа Mockito , которые
автоматически генерируют тестовые двойники. Рассмотрим простой
пример, в котором нужно создать тестовый двойник для объекта List.
Вместо того чтобы возвращать размер List, мы хотим вернуть размер
другого List. Реализуя метод size подставного объекта List, мы не хо-
тим задавать один-единственный ответ. Мы хотим, чтобы ответ был
результатом выполнения некоей операции, поэтому передаем лямб-
да-выражение (пример 7.15).
Пример 7.15  Использование лямбда-выражения в сочетании с
библиотекой Mockito
List<String> list = mock(List.class);
when(list.size()).thenAnswer(inv -> otherList.size());
assertEquals(3, list.size());
В библиотеке Mockito применяется интерфейс Answer , который по-
зволяет предоставить альтернативную реализацию поведения. Иными словами, она уже поддерживает нашего старого знакомца: пере-
дачу кода как данных. Здесь можно использовать лямбда-выражение,
потому что Answer – вот ведь как удачно получилось – функциональ-
ный интерфейс.

Отложенное вычисление и отладка
-------------------------------------
Работа с отладчиком обычно подразумевает пошаговое прохождение
программы или установку точек останова. Иногда при использова-
нии потоковой библиотеки можно столкнуться с ситуацией, когда от-
ладка усложняется, потому что итерированием управляет сама биб-
лиотека, а многие потоковые операции отложены.
При традиционном императивном программировании, когда код
является последовательностью действий, направленных на достиже-
ние цели, исследование состояния до или после действия имеет пря-
мой смысл. В Java 8 сохраняется доступ ко всем существующим в IDE
средствам отладки, но для получения полезных результатов иногда
приходится идти на хитрость.
Протоколирование и печать
*************************
Допустим, требуется отладить код, в котором над коллекцией выпол-
няется последовательность операций, и мы хотим видеть результат
каждой операции по отдельности. Можно было бы распечатывать
коллекцию после каждого шага. Но при работе с потоковой библио-
текой это затруднительно, так как вычисление промежуточных шагов
отложено.
Посмотрим, как можно было бы вывести промежуточные значе-
ния в журнал, взяв за образец императивную версию отчета о нацио-
нальности исполнителей из главы 3. Если вы запамятовали – с кем
не бывает? – напомню, что мы пытаемся найти страну, откуда родом
каждый исполнитель альбома. В примере 7.16 найденные националь-
ности записываются в журнал.

Пример 7.16  Протоколирование промежуточных результатов для
отладки цикла for
Set<String> nationalities = new HashSet<>();
for (Artist artist : album.getMusicianList()) {
if (artist.getName().startsWith("The")) {
String nationality = artist.getNationality();
System.out.println("Found nationality: " + nationality);
Протоколирование и печать
126  Глава 7. Тестирование, отладка и рефакторинг
nationalities.add(nationality);
}
}
return nationalities;
Мы могли бы воспользоваться методом forEach для распечатки
значений из потока, и это заодно привело к выполнению отложен-
ных вычислений. Увы, у такого решения есть недостаток – после вы-
зова forEach продолжить работу с потоком не получится, потому что
поток можно использовать только один раз. И если мы настаиваем
на применении такого подхода, то поток придется создать заново.

Решение: метод peek
По счастью, в потоковой библиотеке есть метод, который позволяет
по очереди просматривать каждое значение и при этом продолжать
операции с потоком. Он называется peek . В примере 7.18 предыдущий
пример переписан с использованием peek, чтобы можно было распе-
чатать значения из потока без необходимости заново запускать кон-
вейер операций.
Пример 7.18  Использование peek для протоколирования промежу-
точных результатов
Set<String> nationalities
= album.getMusicians()
.
 lter(artist -> artist.getName().startsWith("The"))
.map(artist -> artist.getNationality())
.peek(nation -> System.out.println("Found nationality: " + nation))
.collect(Collectors.<String>toSet());

Метод peek можно использовать и для вывода в имеющиеся систе-
мы протоколирования, например log4j , java.util.logging или slf4j, –
точно таким же способом.

Точки останова в середине потока
Протоколирование – лишь один из многих трюков, на которые спо-
собен метод peek. Чтобы отлаживать поток поэлементно, по аналогии
с пошаговым прохождением цикла мы можем поставить точку оста-
нова в теле метода peek.
В данном случае у метода peek может быть пустое тело, внутри ко-
торого ставится точка останова. Некоторые отладчики не позволяют
поставить точку останова в пустом теле, тогда, чтобы удовлетворить
отладчик, я обычно добавляю отображение некоторого значения на
само себя. Решение не идеальное, но работает.
Основные моменты
 Подумайте, как подвергнуть рефакторингу унаследованный код,
применив лямбда-выражения; на этот счет имеются общие реко-
мендации.
 Чтобы автономно протестировать лямбда-выражение любой слож-
ности, поместите его внутрь обычного метода.
 Метод peek очень полезен для протоколирования промежуточных
значений во время отладки.