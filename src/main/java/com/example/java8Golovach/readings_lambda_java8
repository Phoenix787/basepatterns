Функциональным интерфейсом называет интерфейс
с единственным абстрактным методом, который
и является типом лямбда-выражения.

Имя интерфейса      Аргументы   Возвращает  Пример
Predicate<T>        T           Boolean     Этот альбом уже вышел?
Consumer<T>         T           Void        Распечатка значения
Function<T,R>       T           R           Получить имя из объекта Artist
Supplier<T>         Нет         T           Фабричный метод
UnaryOperator<T>    T           T           Логическое НЕТ (!)
BinaryOperator<T>   (T, T)      T           Умножение двух чисел (*)


Predicate<Integer> atLeast5 = x -> x > 5;
Лямбда-выражение, возвращающее значение, также имеет тип Predicate
В данном случае тело лямбда-выражения имеет вид x > 5.

интерфейс BinaryOperator принимает два аргумента одного типа и возвращает
значение того же типа.
BinaryOperator<Long> addLongs = (x, y) -> x + y;

* Лямбда-выражение – это безымянный метод, который служит
для передачи поведения из одного места программы в другое
так, будто это данные.

* Лямбда-выражения выглядят следующим образом:
 BinaryOperator<Integer> add = (x, y)-> x + y.

* Функциональным интерфейсом называется интерфейс с един-
ственным абстрактным методом; он используется в качестве
типа лямбда-выражения.

В Java имеется класс
ThreadLocal, который работает как контейнер значения, локаль-
ного для текущего потока. В Java 8 появился новый фабричный
метод для порождения экземпляров ThreadLocal, который при-
нимает лямбда-выражение, позволяющее создать объект, не за-
водя новых подклассов.

public final static ThreadLocal<DateFormatter> formatter = ThreadLocal.withInitial(() -> new DateFormatter(new SimpleDateFormat("dd-MMM-yyyy")));



Stream – это средство конструирования сложных операций над коллекциями с применением функционального подхода.

Некоторые методы интерфейса Stream
работают иначе. Это обычные методы Java, но возвращенный объект
типа Stream – это не новая коллекция, а рецепт создания коллекции.
allArtists.stream().fillter(artist -> artist.isFrom("London"));
А делает он совсем немного – метод filter строит рецепт обработки
Stream, но нет ничего такого, что привело бы этот рецепт в действие.

Методы, которые, подобно filter, строят рецепты обработки Stream, но
не приводят к порождению нового значения, называются отложенными.
Методы, которые, подобно count, порождают конечное значе-
ние на основе последовательности Stream, называются энергичными

Понять, является операция отложенной или энергичной, очень
просто; достаточно посмотреть, что она возвращает. Если возвраща-
ется Stream, значит, операция отложенная, если что-то другое, в том
числе void, то энергичная.

Функции высшего порядка
На протяжении этой главы мы постоянно встречались с тем, что
в функциональном программировании называют функциями высше-
го порядка. Это функция, которая либо принимает другую функцию
в качестве аргумента, либо возвращает функцию в качестве значе-
ния. Выявить функцию высшего порядка очень просто, достаточно
взглянуть на ее сигнатуру. Если тип аргумента или возвращаемого
значения – функциональный интерфейс, значит, мы имеем функцию
высшего порядка.


С точки зрения вызывающей программы, вызов лямбда-выражения ничем не отличается от вызова метода интерфейса.

Рекомендуется всюду, где возможно, пользоваться функциями, специализированными для примитивных типов, потому что они ра-
ботают быстрее

Разрешение перегрузки
В Java разрешается перегружать методы, то есть иметь несколько ме-
тодов с одним и тем же именем, но разными сигнатурами. Однако при
этом возникает проблема при выведении типов параметров, так как
появляется возможность вывести разные типы. В таких случаях javac
выбирает самый специфический тип.

Пример 4.6. Два перегруженных метода
private void overloadedMethod(Object o) {
System.out.print("Object");
}
private void overloadedMethod(String s) {
System.out.print("String");
}

Тип BinaryOperator – это частный случай типа BiFunction, для кото-
рого типы аргументов и возвращаемого значения одинаковы. Напри-
мер, функция сложения двух целых чисел имеет тип BinaryOperator.
Поскольку тип лямбда-выражения совпадает с типом его функцио-
нального интерфейса, при передаче их в качестве аргументов приме-
нимы те же правила. Мы можем иметь два перегруженных варианта
метода: с параметром типа BinaryOperator и параметром типа расши-
ряющего его интерфейса. При вызове такого метода Java выведет
в качестве типа лямбда-выражения тип самого специфичного функционального интерфейса.

Три правила
Если вы не уверены, что случится при использовании методов по
умолчанию или множественного наследования, руководствуйтесь
следующими тремя простыми правилами разрешения конфликтов.
1. Классу всегда отдается предпочтение перед интерфейсом. Та-
ким образом, если в цепочке родительских классов существует
метод, содержащий тело, или хотя бы его абстрактное объявле-
ние, об интерфейсах вообще можно забыть.
2. Подтипу отдается предпочтение перед супертипом. В ситуа-
ции, когда два интерфейса предоставляют один и тот же метод
по умолчанию и один интерфейс расширяет другой, выигрыва-
ет расширенный интерфейс.
3. Нет никакого правила 3. Если предыдущие два правила не дают
ответа, то подкласс должен либо реализовать метод, либо объ-
явить его абстрактным.
Правило 1 – это то, что обеспечивает совместимость с ранее напи-
санным кодом.

теперь интерфейсы несут с собой некую форму множественного наследования, которое раньше
вызывало порицание и изъятие которого из языка считалось важным
преимуществом Java над C++.
Широко распространено мнение, что настоящая проблема связана с множественным наследованием состоя-
ния, а не просто кода. Но методы по умолчанию как раз запрещают
наследование состояния, то есть обходят самые глубокие ямы, свя-
занные с множественным наследованием в C++.
существует четкое различие между интерфейсами
и абстрактными классами. Интерфейсы открывают возможность мно-
жественного наследования, но не имеют полей, тогда как абстрактные
классы позволяют наследовать поля, но унаследовать сразу несколь-
ким таким классам нельзя. Разрабатывая модель предметной обла-
сти, необходимо помнить об этом компромиссе, что в прежних верси-
ях Java было необязательно.
Cтатическbq метод интерфейса. Это еще одно языковое новшество, появившееся в Java 8

Тип Optional
------------------
есть две формы reduce:
одна – мы ее уже видели – принимает начальное значение, а другая
не принимает. Если начальное значение опущено, то при первом об-
ращении к редуктору используются первые два элемента потока. Это
полезно, когда для операции reduce не существует разумного началь-
ного значения и возвращается экземпляр типа Optional.
Optional – это новый тип данных из базовой библиотеки, призван-
ный предложить более удобную альтернативу null . Старое доброе
значение null у многих вызывает ненависть. Даже его изобретатель
Тони Хоар признался, что это была «ошибка на миллиард долларов».
Вот ведь как плохо быть авторитетным ученым – можно сделать
ошибку на миллиард долларов, а самого миллиарда в глаза не видеть!
Часто null используют, чтобы представить отсутствие значения, и
именно в этом случае Optional предпочтительнее. Проблема в том, что
в случае, когда null обозначает отсутствие значения, возникает всеми
проклинаемое исключение NullPointerException . Стоить обратить-
ся к переменной, содержащей null, как программа «падает». У типа
Optional цель двоякая. Во-первых, он поощряет программиста про-
верять, равна ли переменная null, во избежание ошибок. Во-вторых,
он документирует, какие значения могут отсутствовать в API класса.
В результате проще искать, где могут таиться мины.
Давайте взглянем на API класса Optional, чтобы понять, как его
следует использовать. Чтобы создать экземпляр Optional по имею-
щемуся значению, нужно воспользоваться фабричным методом of.
Отныне экземпляр Optional будет контейнером для этого значения,
а достать его можно с помощью метода get, как показано на рис. 4.22.

Пример 4.22 Создание экземпляра Optional по имеющемуся зна-
чению
Optional<String> a = Optional.of("a");
assertEquals("a", a.get());

Поскольку Optional может также представлять отсутствующее
значение, существует еще фабричный метод empty . А допускающее
null значение можно преобразовать в Optional с помощью метода
ofNullable . Оба способа показаны в примере 4.23 наряду с использо-
ванием метода isPresent (который сообщает, содержит ли данный эк-
земпляр Optional какое-нибудь значение).

Пример 4.23 Создание пустого экземпляра Optional и проверка наличия значения
Optional emptyOptional = Optional.empty();
Optional alsoEmpty = Optional.ofNullable(null);
assertFalse(emptyOptional.isPresent());
// a определено выше
assertTrue(a.isPresent());

Один из способов использования Optional состоит в том, чтобы
перед каждым вызовом get() проверять наличие значение с помощью
isPresent(). Более разумный подход – вызывать метод orElse , кото-
рый возвращает альтернативное значение, если экземпляр Optional
пуст. Если создание альтернативного значения сопряжено с больши-
ми накладными расходами, то лучше использовать метод orElseGet .
Это позволяет передать объект Supplier, который вызывается лишь
в том случае, когда экземпляр Optional действительно пуст.

Пример 4.24 Использование методов orElse и orElseGet
assertEquals("b", emptyOptional.orElse("b"));
assertEquals("c", emptyOptional.orElseGet(() -> "c"));


Optional – обычный класс, который вы можете использовать в соб-
ственном коде, а не только совместно с новыми API, появившимися
в Java 8. Его определенно стоит иметь в виду, когда вы пытаетесь из-
бежать ошибок, связанных со значением null, в том числе неперехва-
ченных исключений.

Основные моменты
-----------------
 Добиться заметного повышения производительности позволя-
ет использование типов лямбда-выражений и потоков, специа-
лизированных для примитивных типов, например IntStream.
 Методами по умолчанию называются методы интерфейсов,
имеющие тела; их объявления начинаются ключевым словом
default.
 Класс Optional позволяет избежать использования null для
представления отсутствующего значения.

Упорядочение элементов
-----------------------
До сих пор я еще ни слова не сказал о том, как упорядочены элемен-
ты в потоках. Вы, наверное, знаете, что для одних типов коллекций,
например List, порядок определен, а для других, например HashSet , –
нет. В случае операций с потоками вопрос об упорядочении оказыва-
ется несколько более сложным.
Интуитивно представляется, что в потоке имеется определенный
порядок, потому что операции производятся над каждым элемен-
том по очереди. Такой порядок называется порядком поступления
Как именно определен порядок поступления, зави-
сит от источника данных и от операций, выполняемых над потоком

Цель потоков – не просто преобразовать одну коллекцию в другую;
важно предоставить общий набор операций над данными. И эти опе-
рации могут создать порядок поступления там, где его изначально не
было.

Если порядок поступления существует, то он распространяется на
последующие операции; например, если мы выполним операцию map
над потоком, в котором есть порядок поступления, то он будет сохранен.
Если же во входном потоке нет порядка поступления, то его не будет и в выходном


У стримов есть некоторые особенности.
Во-первых, обработка не начнётся до тех пор, пока не будет вызван терминальный оператор.
list.stream().filter(x -> x > 100); не возьмёт ни единого элемента из списка.
Во-вторых, стрим после обработки нельзя переиспользовать.
Исходя из первой особенности, делаем вывод, что обработка происходит от терминального оператора к источнику.
Это действительно так и это удобно. Мы можем в качестве источника использовать генерируемую бесконечную последовательность,
скажем, факториала или чисел Фибоначчи, но обрабатывать лишь некоторую её часть.

Пока мы не присоединили терминальный оператор, доступа к источнику не проводилось.
Как только появился терминальный оператор forEach, он стал запрашивать элементы у стоящего перед ним оператора limit.
Тот в свою очередь обращается к map, map к filter, а filter уже обращается к источнику.
Затем элементы поступают в прямом порядке: источник, filter, map, limit и forEach.
Пока какой-либо из операторов не обработает элемент должным образом, новые запрошены не будут.
Как только через оператор limit прошло 3 элемента, он переходит в закрытое состояние и больше не будет запрашивать элементы у map.
forEach запрашивает очередной элемент, но limit сообщает, что больше не может поставить элементов,
поэтому forEach делает вывод, что элементы закончились и прекращает работу.

Параллельные стримы

Стримы бывают последовательными (sequential) и параллельными (parallel).
Последовательные выполняются только в текущем потоке, а вот параллельные используют общий пул ForkJoinPool.commonPool().
При этом элементы разбиваются (если это возможно) на несколько групп и обрабатываются в каждом потоке отдельно.
Затем на нужном этапе группы объединяются в одну для предоставления конечного результата.

Чтобы получить параллельный стрим, нужно либо вызвать метод parallelStream() вместо stream(),
либо превратить обычный стрим в параллельный, вызвав промежуточный оператор parallel.