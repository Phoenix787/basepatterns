Знакомство с интерфейсом Collector
-----------------------------------
коллектор – конструкцию общего ха-
рактера для порождения составных значений из потоков. Коллектор
можно использовать с произвольным потоком, передав его в качестве
аргумента метода collect.
В стандартной библиотеке имеется ряд готовых полезных коллек-
торов, поэтому для начала познакомимся с ними. В примерах кода
из этой главы коллекторы статически импортируются из класса java.
util.stream.Collectors.

Порождение других коллекций
Некоторые коллекторы просто конструируют другие коллекции. Мы
уже встречались с коллектором toList , который порождает экземпля-
ры класса java.util.List. Есть также коллекторы toSet и toCollection ,
порождающие соответственно экземпляры Set и Collection.

Collection. Я уже
много говорил о сцеплении операций Stream, но все же бывают случаи,
когда в качестве конечного значения требуется получить Collection.
Например:
 при передаче коллекции в существующий код, рассчитанный
на работу с коллекциями;
 при создании конечного значения в конце цепочки коллекций;
 при написании в тесте утверждения, относящегося к конкрет-
ной коллекции.

Обычно при создании коллекции мы указываем конкретный тип,
вызывая соответствующий конструктор:
List<Artist> artists = new ArrayList<>();
Но при обращении к методу toList или toSet задавать конкретную
реализацию List или Set не нужно. Потоковая библиотека сама вы-
берет подходящую реализацию.

Иногда желательно, чтобы метод collect создавал коллекцию кон-
кретного типа, если она понадобится в дальнейшем. Например, не ис-
ключено, что вам нужен объект класса TreeSet , а не того подкласса
Set, который выбрала бы библиотека. Это можно сделать, восполь-
зовавшись коллектором toCollection, который принимает в качестве
аргумента функцию, конструирующую коллекцию (см. пример 5.5).

Пример 5.5 Создание конкретной коллекции с помощью метода
toCollection
stream.collect(toCollection(TreeSet::new));

Порождение других значений
Коллекторы позволяют сворачивать коллекцию в одно значение. Так,
коллекторы maxBy и minBy дают возможность получить одно значение
в соответствии с некоторым отношением порядка

//Нахождение группы с наибольшим числом участников
    public Optional<Artist> biggestGroup(Stream<Artist> artists){
        Function<Artist, Long> getCount = artist -> artist.getMembers().count();
        return artists.collect(maxBy(comparing(getCount)));
    }

    Здесь задается лямбда-выражение, отображающее исполнителя на количест во
    участников. Затем оно используется для определения компаратора,
    который передается в коллектор maxBy.

Существуют также коллекторы, реализующие стандартные опера-
ции над числами. Познакомимся с ними, написав компонент, кото-
рый находит среднее число произведений в альбоме (пример 5.7).

Пример 5.7 Нахождение среднего числа произведений во всех альбомах из списка
public double averageNumberOfTracks(List<Album> albums) {
    return albums.stream()
            .collect(averagingInt(album -> album.getTrackList().size()));
}

Как обычно, мы запускаем конвейер методом stream, а затем со-
бираем результаты методом collect. После этого мы вызываем метод
averagingInt, который принимает лямбда-выражение, преобразующее
каждый элемент потока в число типа int, перед тем как усреднить
результаты.

Существует группа коллекторов, предлагающих похожие функциональные возможности, одним
из них как раз и является averagingInt. Значения можно складывать
с помощью метода summingInt и его вариантов для других типов. С помощью метода summarizingInt и ему подобных можно собирать
сводную статистику SummaryStatistics

==============================================
Разбиение данных
==============================================
Еще одна типичная операция интерфейса Stream – разбиение потока
на две коллекции значений. Например, поток исполнителей можно
разбить на солистов и группы. Один из подходов к решению этой
задачи – произвести две операции фильтрации: сначала найти соли-
стов, потом группы.
Но у такого подхода есть два недостатка. Во-первых, для выполне-
ния двух операций потребуются два потока. Во-вторых, если перед
фильтрами выполняется длинная последовательность других опера-
ций, то все эти операции придется выполнять дважды – в одном и
в другом потоке. Такой код чистым не назовешь.

Поэтому существует коллектор partitioningBy , который принимает
поток и разбивает его содержимое на две группы.
Чтобы определить, куда какой элемент поместить, этот коллектор пользуется предикатом Predicate, а возвращает отображение Map,
сопоставляющее булеву значению список List. Таким образом, в списке, соответствующем значению true, будут находиться элементы потока,
для которых предикат вернул true, в списке, соответствующем значению false, – все остальные.

С помощью этого механизма мы можем отделить группы (исполнители с несколькими участниками) от солистов. В данном случае
функция разбиения сообщает, является ли исполнитель солистом.

=========================================================
Группировка данных
=========================================================
Существует естественный способ обобщить разбиение, изменив опе-
рацию группировки. Большая общность заключается в том, что вмес-
то двух групп, соответствующих значениям true и false, мы можем
создать сколько угодно групп, каждой из которых соответствует не-
которое общее значение. Предположим, что вы получили откуда-то
поток альбомов и хотите сгруппировать их по имени основного музы-
канта.

Группировка альбомов по основному исполнителю
public Map<Artist, List<Album>> albumsByArtist(Stream<Album> albums) {
return albums.collect(groupingBy(album -> album.getMainMusician()));
}

Как и в других примерах, мы вызываем метод collect потока Stream,
передавая ему объект Collector. Коллектор groupingBy (рис. 5.2) при-
нимает функцию classifier, которая разбивает данные, – точно так же,
как коллектор partitioningBy принимал предикат, относивший эле-
менты потока к двум категориям: true и false. Классификатор имеет
тип Function – такой же, как применяется в операции map
 //аналогична SQL group by

=================================================================
Строки
=================================================================
Очень часто сбор данных из потоков организуется для того, чтобы
в конце сгенерировать строки. Предположим, что мы хотим создать
отформатированный список имен исполнителей, участвовавших
в запи си альбома. Если, например, альбом называется «Let It Be», то
на выходе мы ожидаем получить строку "[George Harrison, John Lennon,
Paul McCartney, Ringo Starr, The Beatles]".

До выхода Java 8 мы написали бы для решения этой задачи код вро-
де того, что приведен в примере 5.11. Здесь мы обходим список испол-
нителей и для построения строки пользуемся объектом StringBuilder.
На каждой итерации извлекается имя исполнителя и добавляется
в StringBuilder.

Пример 5.11  Форматирование имен исполнителей в цикле
StringBuilder builder = new StringBuilder("[");
for (Artist artist : artists) {
if (builder.length() > 1)
builder.append(", ");
String name = artist.getName();
builder.append(name);
}
builder.append("]");
String result = builder.toString();

Конечно, этот код шедевром не назовешь. Довольно трудно понять,
что здесь происходит, не пройдя по всей программе шаг за шагом.
В Java 8 с помощью потоков и коллекторов то же самое можно запи-
сать гораздо яснее (пример 5.12).

Пример 5.12  Форматирование имен исполнителей с помощью по-
токов и коллекторов
String result =
artists.stream()
.map(Artist::getName)
.collect(Collectors.joining(", ", "[", "]"));

Здесь мы с помощью map извлекаем имена исполнителей, а затем
собираем данные из потока с помощью коллектора Collectors.joining .
Этот метод – удобное средство построения строк из данных, полу-
чаемых из потока. В нем можно задать разделитель (символ, встав-
ляемый между элементами), а также начальный и конечный ограни-
читель.

===================================================================
Композиция коллекторов
=====================================================================
Коллекторы, с которыми мы уже познакомились, сами по себе до-
вольно мощные, но их мощь многократно возрастает благодаря воз-
можности композиции.

Ранее мы группировали альбомы по основному исполнителю,
а теперь займемся задачей подсчета количества альбомов, в которых
участвовал каждый исполнитель. Для этого можно просто приме-
нить предыдущую группировку, а затем подсчитать число элементов
в группе.

Наивный подход к подсчету количества альбомов для
каждого исполнителя
Map<Artist, List<Album>> albumsByArtist
= albums.collect(groupingBy(album -> album.getMainMusician()));
Map<Artist, Integer> numberOfAlbums = new HashMap<>();
for(Entry<Artist, List<Album>> entry : albumsByArtist.entrySet()) {
numberOfAlbums.put(entry.getKey(), entry.getValue().size());
}

Гм, просто, конечно, но как-то неряшливо. Это императивный код,
не допускающий автоматического распараллеливания.
А хотелось бы иметь еще один коллектор, который говорит
groupingBy, что вместо построения списка альбомов для каждого ис-
полнителя их нужно просто пересчитать. И надо же – в базовой библиотеке как раз такой коллектор есть, и называется он counting

Использование коллекторов для подсчета количества
альбомов для каждого исполнителя
public Map<Artist, Long> numberOfAlbums(Stream<Album> albums) {
return albums.collect(groupingBy(album -> album.getMainMusician(),
counting()));
}

Этот вариант groupingBy разбивает множество элементов на клас-
теры. Каждый кластер ассоциируется с ключом, который предо-
ставляет функция классификации: getMainMusician. Затем операция
groupingBy использует подчиненный коллектор для сбора данных из
каждого кластера и создает отображение Map, содержащее результаты.

Рассмотрим еще один пример, в котором вместо группировки аль-
бомов нам нужны только их названия. Можно было бы снова взять
исходный коллектор, а затем подправить результирующие значения
в Map. Как это сделать, показано в примере 5.15.
Пример 5.15  Наивный подход к нахождению названий всех альбо-
мов, в записи который участвовал исполнитель
public Map<Artist, List<String>> nameOfAlbumsDumb(Stream<Album> albums) {
Map<Artist, List<Album>> albumsByArtist =
albums.collect(groupingBy(album ->album.getMainMusician()));
Map<Artist, List<String>> nameOfAlbums = new HashMap<>();
for(Entry<Artist, List<Album>> entry : albumsByArtist.entrySet()) {
nameOfAlbums.put(entry.getKey(), entry.getValue()
.stream()
.map(Album::getName)
.collect(toList()));
}
return nameOfAlbums;
}
Как и раньше, можно написать более элегантный, быстрый и до-
пускающий распараллеливание код, воспользовавшись еще одним
коллектором. Мы уже умеем группировать альбомы по основному
исполнителю с помощью коллектора groupingBy, однако он порождает
объект Map<Artist, List<Album>>. А нам нужно ассоциировать с каждым
объектом Artist не список альбомов, а список строк, содержащих на-
звания альбомов.
В данном случае мы хотели бы выполнить операцию map над спис-
ком, сопоставив каждому исполнителю название альбома. Но мы не можем просто воспользоваться методом map потока, потому что нуж-
ный нам список создан коллектором groupingBy. Необходимо как-то
сказать коллектору groupingBy, чтобы он применил map к значениям,
помещаемым в результирующий список.

------------------------------------------------------------
Любой коллектор – это рецепт построения конечного значения
------------------------------------------------------------

Нам нужен рецепт получения другого рецепта – еще одного коллекто-
ра. К счастью, умные головы в Oracle предусмотрели такой случай и
включили коллектор, который называется mapping .
Коллектор mapping позволяет выполнять операции типа map над
контейнером другого коллектора. Еще ему нужно сказать, в какой
коллекции сохранять результаты, это можно сделать с помощью кол-
лектора toList. На всем пути сплошные коллекторы!
Как и операция map, коллектор получает на входе реализацию ин-
терфейса Function. После рефакторинга с использованием второго
коллектора получается код, показанный в примере 5.16.
Пример 5.16  Применение коллекторов для нахождения названий
альбомов, в записи которых принимал участие исполнитель
public Map<Artist, List<String>> nameOfAlbums(Stream<Album> albums) {
return albums.collect(groupingBy(Album::getMainMusician,
mapping(Album::getName, toList())));
}
В обоих случаях мы использовали второй коллектор для обработ-
ки части конечного результата. Такие коллекторы называются подчиненными (downstream).

Если коллектор – это рецепт построения конечного значения, то подчиненный коллектор – рецепт построения
части этого значения, которая затем используется главным коллектором.
Возможность такой композиции коллекторов превращает их
в еще более мощный компонент потоковой библиотеки.
Функции, специализированные для примитивных типов, напри-
мер averagingInt или summarizingLong , на самом деле не дают ничего
нового, по сравнению с вызовом метода самого специализированного
потока. А истинное их предназначение – использоваться в качестве
подчиненных коллекторов.

коллекторы могут собирать данные параллельно, мы покажем операцию сборки,
в которой два контейнерных объекта (например, StringCombiner) используются параллельно.

R collect​(Collector collector)
---------------------------------
Один из самых мощных операторов Stream API. С его помощью можно собрать все элементы в список, множество или другую коллекцию,
сгруппировать элементы по какому-нибудь критерию, объединить всё в строку и т.д.. В классе java.util.stream.Collectors
очень много методов на все случаи жизни, мы рассмотрим их позже.
При желании можно написать свой коллектор, реализовав интерфейс Collector.


    List<Integer> list = Stream.of(1, 2, 3)
        .collect(Collectors.toList());
    // list: [1, 2, 3]

    String s = Stream.of(1, 2, 3)
        .map(String::valueOf)
        .collect(Collectors.joining("-", "<", ">"));
    // s: "<1-2-3>"



R collect​(Supplier supplier, BiConsumer accumulator, BiConsumer combiner)
То же, что и collect(collector), только параметры разбиты для удобства.
Если нужно быстро сделать какую-то операцию, нет нужды реализовывать интерфейс Collector, достаточно передать три лямбда-выражения.

supplier должен поставлять новые объекты (контейнеры),
например new ArrayList(), accumulator добавляет элемент в контейнер, combiner необходим для параллельных стримов и объединяет части стрима воедино.

    List<String> list = Stream.of("a", "b", "c", "d")
        .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
    // list: ["a", "b", "c", "d"]
